package nl.rsm.tom.drones.solver.algorithms;

import java.util.ArrayList;
import java.util.List;

import nl.rsm.tom.drones.data.Operation;
import nl.rsm.tom.drones.data.Solution;
import nl.rsm.tom.drones.data.instance.Instance;
import nl.rsm.tom.drones.solver.FixedOrderSolver;
import nl.rsm.tom.drones.solver.algorithms.localsearch.Action;
import nl.rsm.tom.drones.solver.algorithms.localsearch.AllActionProvider;

/**
 * This is an abstract class that implements important aspects of a local
 * search approach for the problem. It combines full neighborhood search
 * with a fixed order solver.
 * @author Paul Bouman
 *
 * @param <E> the type of the locations in the instance
 */
public abstract class FixedOrderLocalSearchBase<E>
{
	private FixedOrderSolver<E> solver;

	private Instance<E> instance;
	
	private ArrayList<E> currentOrder;
	private Solution<E> currentSolution;
	
	private AllActionProvider<E> allActions;
	
	/**
	 * Base constructor that initializes important information
	 * for performing a local search heuristic
	 * @param instance the instance on which a search will be performed
	 * @param initial the initial solution that this search will start with
	 * @param allActions a provider for the neighbourhood in the search
	 * @param solver a FixedOrderSolver that is used to turn a sequence into an
	 *               actual solution
	 */
	public FixedOrderLocalSearchBase(Instance<E> instance, Solution<E> initial,
										AllActionProvider<E> allActions,
										FixedOrderSolver<E> solver)
	{
		this.solver = solver;
		this.instance = instance;
		this.allActions = allActions;
		this.currentOrder = new ArrayList<>();
		for (Operation<E> op : initial)
		{
			if (!instance.isDepot(op.getEnd()))
			{
				currentOrder.add(op.getEnd());
			}
		}
		recomputeSolution();
	}
	
	/**
	 * Retrieve the current solution found by this localsearch heuristic
	 * @return
	 */
	public Solution<E> getCurrentSolution()
	{
		return currentSolution;
	}
	
	private void recomputeSolution()
	{
		currentSolution = solver.solve(instance, addDepots(currentOrder, instance));
	}
	
	/**
	 * Perform an action on the current order maintained by this local search heuristic 
	 * @param action the action to perform
	 */
	public void doAction(Action<E> action)
	{
		if (action == null)
		{
			throw new IllegalArgumentException("The action cannot be null");
		}
		action.doAction(currentOrder);
		recomputeSolution();
	}
	
	/**
	 * Undo an action that was previously executed. Note that no check is
	 * performed whether this action was executed previously
	 * @param action the action to undo
	 */
	public void undoAction(Action<E> action)
	{
		if (action == null)
		{
			throw new IllegalArgumentException("The action cannot be null");
		}
		action.undoAction(currentOrder);
		recomputeSolution();
	}
	
	/**
	 * Finds the best action generated by the AllActionProvider such that
	 * the solution found by the solver after applying that action is 
	 * maximal 
	 * @return the best action found
	 */
	public Action<E> getBestAction()
	{
		Action<E> best = null;
		double bestSavings = 0;
		double curValue = currentSolution.getTotalCost();
		
		for (Action<E> a : allActions.getActions(currentOrder, instance))
		{
			a.doAction(currentOrder);
			Solution<E> newSol = solver.solve(instance, addDepots(currentOrder, instance));
			double savings = curValue - newSol.getTotalCost();
			if (savings > bestSavings)
			{
				best = a;
				bestSavings = savings;
			}
			a.undoAction(currentOrder);
		}
		return best;
	}
	
	/**
	 * Runs the local search heuristic
	 */
	public abstract void solve();
	
	private ArrayList<E> addDepots(List<E> l, Instance<E> i)
	{
		ArrayList<E> res = new ArrayList<E>(l.size() + 2);
		res.add(i.getDepot());
		res.addAll(l);
		res.add(i.getDepot());
		return res;
	}
	
}
